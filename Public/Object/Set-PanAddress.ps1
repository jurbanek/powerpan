function Set-PanAddress {
<#
.SYNOPSIS
Update or create address objects in the candidate configuration
.DESCRIPTION
Set-PanAddress will update an address object if the name already exists. If the name does not exist, it will be created.
.NOTES
Set-PanAddress is responsible for both creating new remote address objects and updating existing remote address objects.

Two modes: -InputObject mode and -Device mode.

:: InputObject Mode (-InputObject)::
Take one or more PanAddress objects and apply them remotely as is to create or update using API action=edit (replace)
The device and location (vsys, device-group) are gleaned from PanAddress.Device and PanAddress.Location properties.
An administrator can get PanAddress object "the way they want it" and then pipe it to Set-PanAddress.

:: Device Mode (-Device)::
Device mode is more nuanced. It can also be used to create remote address objects or update remote address objects.
Device mode does not take a PanAddress input. Required parameters are -Device, -Location, and -Name.
Remaining parameters are not required by the cmdlet, but may be required by the XML API depending on if the object already exists or not.
This flexibility offers interactive power as not all values have to be specified all the time.

:: Device Mode Replace (-Device -Replace) ::
By default Set-PanAddress -Device uses "merge" API action=set (Invoke-PanXApi -Config -Set).
To use "replace" API action=edit (Invoke-PanXApi -Config -Edit), include the -Replace switch.

:: Rename & Move ::
Set-PanAddress cannot be used to rename objects. Use Rename- cmdlet.
Set-PanAddress cannot be used to move object locations. Use Move- cmdlet.
.INPUTS
PanDevice[]
   You can pipe a PanDevice to this cmdlet
PanAddress[]
   You can pipe a PanAddress to this cmdlet
.OUTPUTS
PanAddress
.EXAMPLE
Create a new PanAddress on NGFW

$D = Get-PanDevice "fw.lab.local"
Set-PanAddress -Device $D -Location "vsys1" -Name "H-1.1.1.1" -Value "1.1.1.1" -Type "ip-netmask"

If H-1.1.1.1 already exists in vsys1, the update wll be merged.
.EXAMPLE
Create a new PanAddress on Panorama

$D = Get-PanDevice "panorama.lab.local"
Set-PanAddress -Device $D -Location "MyDeviceGroup" -Name "H-1.1.1.1" -Value "1.1.1.1" -Type "ip-netmask"

If H-1.1.1.1 already exists in MyDeviceGroup, the update wll be merged.
.EXAMPLE
Add a description to an object that already exists.

$D = Get-PanDevice "fw.lab.local"
Set-PanAddress -Device $D -Location "vsys1" -Name "H-1.1.1.1" -Description "Updated Description!"

If the object did NOT exist already, the command would error remotely by the API (with details) as a -Type and -Value are required for new objects to be created.
.EXAMPLE
Updates the PanAddress object locally adding/updating a description and tags (tags must already exist in PAN-OS) and replaces the configuration in the candidate configuration.
Piping PanAddress to Set-PanAddress replaces the full object on the PanDevice (replace, not merge), WYSIWYG.

$D = Get-PanDevice "fw.lab.local"
$A = Get-PanAddress -Device $D -Location "vsys1" -Name "H-1.1.1.1"
$A.Description = "Updated Description!"
$A.Tag = @('risky','review')
$A | Set-PanAddress
.EXAMPLE
Removing a description and removing tags
Assume H-1.1.1.1 has a description to be removed and tags to be removed
Piping PanAddress to Set-PanAddress replaces the full object on the PanDevice (replace, not merge), WYSIWYG

$D = Get-PanDevice "fw.lab.local"
$A = Get-PanAddress -Device $D -Location "vsys1" -Name "H-1.1.1.1"
$A.Description = ""
$A.Tag = @()
$A | Set-PanAddress
.EXAMPLE
Get-PanDevice "fw.lab.local" | Set-PanAddress -Location "vsys1" -Type 'fqdn' -Name "FQDN-raw.githubusercontent.com" -Value "raw.githubusercontent.com"

Creates a fqdn address object with name "FQDN-raw.githubusercontent.com" and value "raw.githubusercontent.com"
If address object with specified name already exists, the value is updated to "raw.githubusercontent.com".
If address object with specified name already exists and the value is incompatible with the type, an error will be generated by the API
.EXAMPLE
Get-PanDevice "fw.lab.local" |
   Get-PanAddress -Filter "10.16" |
   Where-Object {$_.Type -eq 'ip-netmask' -and $_.Value -match "^10\.16\."} |
   ForEach-Object {$_.Tag += "DC-A"; $_} |
   Set-PanAddress 

Adding a "DC-A" tag to all ip-netmask type objects starting with 10.16 on fw.lab.local
Note: in example Set-PanAddress does not require use of -Replace given piping of PanAddress (-InputObject)
.EXAMPLE
Get-PanDevice "fw1.lab.local","fw2.lab.local" |
   Get-PanAddress |
   Where-Object {"review" -in $_.Tag} |
   ForEach-Object {$_.Tag = $_.Tag | Where-Object {$_ -ne "review"}; $_} |
   Set-PanAddress -Replace

Remove the "review" tag from every address object on fw1.lab.local and fw2.lab.local
Note: in example Set-PanAddress does not require use of -Replace given piping of PanAddress (-InputObject)

Not quite a PowerShell "one-liner" as the Foreach-Object ScriptBlock contains semi-colons, but close.
Illustrates the capabilities of the PowerPAN, but not wise to do it exactly this way.
If doing something like this in production, use proper foreach() loops and a few more variables.
The $_ nesting present in the ForEach-Object and nested Where-Object is error-prone if not careful.
On large devices with many objects with the "review" tag, might take a while.
#>
   [CmdletBinding()]
   param(
      [parameter(Mandatory=$true,ParameterSetName='Device',ValueFromPipeline=$true,HelpMessage='PanDevice against which address object(s) will be applied')]
      [PanDevice[]] $Device,
      [parameter(Mandatory=$true,ParameterSetName='Device',HelpMessage='Case-sensitive location: vsys1, shared, DeviceGroupA, etc.')]
      [String] $Location,
      [parameter(Mandatory=$true,ParameterSetName='Device',HelpMessage='Case-sensitive name of address object')]
      [String] $Name,
      [parameter(ParameterSetName='Device',HelpMessage='Value of the address object')]
      [String] $Value,
      [parameter(ParameterSetName='Device',HelpMessage='Type of the address object: ip-netmask, fqdn, ip-range, ip-wildcard')]
      [ValidateSet('ip-netmask','fqdn','ip-range','ip-wildcard')]
      [String] $Type,
      [parameter(ParameterSetName='Device',HelpMessage='Description')]
      [String] $Description,
      [parameter(ParameterSetName='Device',HelpMessage='One or more tags. Tags must exist already. Will not create tags')]
      [String[]] $Tag,
      [parameter(ParameterSetName='Device',HelpMessage='Replace (action=edit) instead of merge (action=set)')]
      [Switch] $Replace,
      [parameter(ParameterSetName='Device',HelpMessage='Disable ability to override (Panorama device-group objects only)')]
      [Bool] $DisableOverride,
      [parameter(Mandatory=$true,Position=0,ParameterSetName='InputObject',ValueFromPipeline=$true,HelpMessage='PanAddress input object(s) to be applied as is')]
      [PanAddress[]] $InputObject
      
   )

   Begin {
      # Propagate -Debug and -Verbose to this module function, https://tinyurl.com/y5dcbb34
      if($PSBoundParameters.Debug) { $DebugPreference = 'Continue' }
      if($PSBoundParameters.Verbose) { $VerbosePreference = 'Continue' }
      # Announce
      Write-Debug ($MyInvocation.MyCommand.Name + ':')
   } # Begin Block

   Process {
      # ParameterSetName InputObject
      if($PSCmdlet.ParameterSetName -eq 'InputObject') {
         foreach($InputObjectCur in $PSBoundParameters.InputObject) {
            Write-Debug ('{0}: InputObject Device: {1} XPath: {2}' -f $MyInvocation.MyCommand.Name,$InputObjectCur.Device.Name,$InputObjectCur.XPath)
            # InputObject is always action=edit, overlap between XPath and Element (entry.OuterXml)
            Write-Debug ('{0}: InputObject (-Edit)XML: {1}' -f $MyInvocation.MyCommand.Name,$InputObjectCur.XDoc.entry.OuterXml)
            $Response = Invoke-PanXApi -Device $InputObjectCur.Device -Config -Edit -XPath $InputObjectCur.XPath -Element $InputObjectCur.XDoc.entry.OuterXml
            # Check PanResponse
            if($Response.Status -eq 'success') {
               # Send the updated object back to the pipeline for further use or to display
               Get-PanAddress -InputObject $InputObjectCur
            }
            else {
               Write-Error ('Error applying InputObject {0} on {1}/{2} . Status: {3} Code: {4} Message: {5}' -f
                  $InputObjectCur.Name,$InputObjectCur.Device.Name,$InputObjectCur.Location,$Response.Status,$Response.Code,$Response.Message)
            }
         } # End foreach InputObjectCur
      } # End ParameterSetName InputObject
      
      # ParameterSetName Device
      elseif($PSCmdlet.ParameterSetName -eq 'Device') {
         foreach($DeviceCur in $PSBoundParameters.Device) {
            # If object already exists, use it
            Write-Debug ('{0}: Device: {1} Location: {2} Name: {3} ' -f $MyInvocation.MyCommand.Name,$DeviceCur.Name,$PSBoundParameters.Location,$PSBoundParameters.Name)
            # Find if object already exists, limit search to specified Location. Get-PanAddress is case-insensitive but performs server-side filtering greatly reducing returned objects
            # Tighten up the case-sensitivity locally here with Where-Object
            $Address = $null
            $Address = Get-PanAddress -Device $DeviceCur -Location $PSBoundParameters.Location -Filter $PSBoundParameters.Name | Where-Object {$_.Name -cmatch $PSBoundParameters.Name}
            if($Address) {
               Write-Debug ('{0}: Found {1} on Device: {2}/{3} at XPath: {4}' -f $MyInvocation.MyCommand.Name,$PSBoundParameters.Name,$DeviceCur.Name,$PSBoundParameters.Location,$Address.XPath)
               # Use the existing address and modify the properties directly letting the PanAddress to the XML lifting
               # Device, Location, and Name do not apply
               if($PSBoundParameters.Value) { $Address.Value = $PSBoundParameters.Value }
               if($PSBoundParameters.Type) { $Address.Type = $PSBoundParameters.Type }
               if($PSBoundParameters.Description) { $Address.Description = $PSBoundParameters.Description }
               if($PSBoundParameters.Tag) { $Address.Tag = $PSBoundParameters.Tag }
               # Since DisableOverride value can be $false, need to check its presence with ContainsKey()
               if($PSBoundParameters.ContainsKey('DisableOverride')) { $Address.DisableOverride = $PSBoundParameters.DisableOverride }

               # Call API
               if(-not $PSBoundParameters.Replace.IsPresent) {
                  Write-Debug ('{0}: Device (-Set)XML: {1}' -f $MyInvocation.MyCommand.Name,$Address.XDoc.entry.InnerXml)
                  $Response = Invoke-PanXApi -Device $DeviceCur -Config -Set -XPath $Address.XPath -Element $Address.XDoc.entry.InnerXml
               }
               else {
                  Write-Debug ('{0}: Device (-Edit)XML: {1}' -f $MyInvocation.MyCommand.Name,$Address.XDoc.entry.OuterXml)
                  $Response = Invoke-PanXApi -Device $DeviceCur -Config -Edit -XPath $Address.XPath -Element $Address.XDoc.entry.OuterXml
               }
            }
            # If object does not exist, build it. Cmdlet does not check for completeness of built objects
            else {
               Write-Debug ('{0}: Cannot find {1} on Device: {2}/{3}. Building' -f $MyInvocation.MyCommand.Name,$PSBoundParameters.Name,$DeviceCur.Name,$PSBoundParameters.Location)
               # XPath
               $XPath = "{0}/address/entry[@name='{1}']" -f $PSBoundParameters.Device.Location.($PSBoundParameters.Location),$PSBoundParameters.Name
               # XDoc
               $XDoc = [System.Xml.XmlDocument]::new()
               # Create <entry name="MyName"></entry> and append to the XDoc
               $XEntry = $XDoc.CreateElement('entry')
               $XEntry.SetAttribute('name',$PSBoundParameters.Name)
               $XDoc.AppendChild($XEntry) | Out-Null

               # Type
               if($PSBoundParameters.Type) {
                  $XType = $XDoc.CreateElement($PSBoundParameters.Type)
                  $XType.InnerText = $PSBoundParameters.Value
                  $XEntry.AppendChild($XType) | Out-Null
               }
               # Description
               if($PSBoundParameters.Description) {
                  $XDescription = $XDoc.CreateElement('description')
                  $XDescription.InnerText = $PSBoundParameters.Description
                  $XEntry.AppendChild($XDescription) | Out-Null
               }
               # Tag
               if($PSBoundParameters.Tag) {
                  $XTag = $XDoc.CreateElement('tag')
                  $XEntry.AppendChild($XTag) | Out-Null
                  foreach($TagCur in $PSBoundParameters.Tag) {
                     $XMember = $XDoc.CreateElement('member')
                     $XMember.InnerText = $TagCur
                     $XTag.AppendChild($XMember) | Out-Null
                  }
               }
               # DisableOverride
               if($PSBoundParameters.ContainsKey('DisableOverride')) {
                  $XDisable = $XDoc.CreateElement('disable-override')
                  switch($PSBoundParameters.DisableOverride) {
                     $false   { $XDisable.InnerText = 'no' }
                     $true    { $XDisable.InnerText = 'yes' }
                  }
                  $XEntry.AppendChild($XDisable) | Out-Null
               }

               # Call API
               if(-not $PSBoundParameters.Replace.IsPresent) {
                  Write-Debug ('{0}: Device (-Set)XML: {1}' -f $MyInvocation.MyCommand.Name,$XDoc.entry.InnerXml)
                  $Response = Invoke-PanXApi -Device $DeviceCur -Config -Set -XPath $XPath -Element $XDoc.entry.InnerXml
               }
               else {
                  Write-Debug ('{0}: Device (-Edit)XML: {1}' -f $MyInvocation.MyCommand.Name,$XDoc.entry.OuterXml)
                  $Response = Invoke-PanXApi -Device $DeviceCur -Config -Edit -XPath $XPath -Element $XDoc.entry.OuterXml
               }
            } # End object does not exist, build

            # Check PanResponse
            if($Response.Status -eq 'success') {
               # Send the updated object back to the pipeline for further use or to display
               Get-PanAddress -Device $DeviceCur -Location $PSBoundParameters.Location -Name $PSBoundParameters.Name
            }
            else {
               Write-Error ('Error applying address {0} on {1}/{2} . Status: {3} Code: {4} Message: {5}' -f
                  $PSBoundParameters.Name,$DeviceCur.Name,$PSBoundParameters.Location,$Response.Status,$Response.Code,$Response.Message)
            }
         } # End foreach $DeviceCur
      } # End ParameterSetName Device
   } # Process block
   End {
   } # End block
} # Function
